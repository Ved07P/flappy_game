<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flappy Custom Game</title>
<style>
    body {
        margin: 0;
        padding: 0;
        background-color: #333;
        font-family: 'Arial', sans-serif;
        overflow: hidden;
        touch-action: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }
    #game-container {
        position: relative;
        width: 100%;
        height: 100%;
        max-width: 480px;
        background-color: #70c5ce;
        overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; }
    .ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; display: flex; flex-direction: column; align-items: center;
    }
    .score-board {
        margin-top: 50px; text-align: center; color: white;
        text-shadow: 2px 2px 0 #000; font-weight: bold; font-size: 3rem;
    }
    #high-score-display { font-size: 1.2rem; display:block; margin-top:5px; }
    #menu-screen {
        position: absolute; top:0; left:0; width:100%; height:100%;
        background: rgba(0,0,0,0.5); display:flex; flex-direction: column;
        justify-content: center; align-items: center; z-index:20;
        pointer-events: auto; cursor: pointer;
    }
    #menu-screen h1 { color:white; font-size:3rem; margin:0 0 20px 0; text-shadow:3px 3px 0 #000; text-align:center; }
    #menu-screen p { color:#fff; font-size:1.5rem; animation: blink 1s infinite; }
    @keyframes blink { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
    #assets { display:none; }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
        <div class="score-board">
            <span id="current-score">0</span>
            <span id="high-score-display">High: 0</span>
        </div>
    </div>
    <div id="menu-screen">
        <h1 id="title-text">FLAPPY<br>GAME</h1>
        <p id="info-text">Tap to Start</p>
    </div>
</div>

<div id="assets">
    <img id="playerImg" src="player.png" alt="Player">
    <audio id="jumpSound" src="jump.mp3" preload="auto"></audio>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('current-score');
const highScoreEl = document.getElementById('high-score-display');
const menuScreen = document.getElementById('menu-screen');
const titleText = document.getElementById('title-text');
const infoText = document.getElementById('info-text');

const birdImg = document.getElementById('playerImg');
const jumpAudio = document.getElementById('jumpSound');

let frames=0, score=0, highScore = localStorage.getItem('flappyHighScore') || 0;
let gameState='START', gameSpeed=3;

highScoreEl.innerText = `High: ${highScore}`;

const bird = {
    x:50, y:150, width:40, height:30, velocity:0, gravity:0.25, jumpStrength:4.6, rotation:0,
    draw: function() {
        ctx.save();
        ctx.translate(this.x,this.y);
        if(gameState!=='START') {
            if(this.velocity<0) this.rotation = -25*Math.PI/180;
            else { this.rotation += 0.1; if(this.rotation > 90*Math.PI/180) this.rotation = 90*Math.PI/180; }
        } else this.rotation = 0;
        ctx.rotate(this.rotation);
        
        if(birdImg.complete && birdImg.naturalHeight!==0){
            ctx.drawImage(birdImg, -this.width/2, -this.height/2, this.width, this.height);
        } else {
            // Fallback yellow bird
            ctx.fillStyle="yellow"; ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            ctx.fillStyle="black"; ctx.fillRect(this.width/4, -this.height/2+2, 4, 4); // Eye
            ctx.fillStyle="orange"; ctx.fillRect(this.width/4, 2, 10, 8); // Beak
        }
        ctx.restore();
    },
    update: function(){
        this.velocity += this.gravity;
        this.y += this.velocity;
        if(this.y + this.height/2 >= canvas.height - 20){ this.y = canvas.height - 20 - this.height/2; gameOver(); }
        if(this.y < 0) { this.y = 0; this.velocity = 0; }
    },
    flap: function(){
        this.velocity = -this.jumpStrength;
        if(jumpAudio && jumpAudio.readyState >= 2) { 
            jumpAudio.currentTime=0; jumpAudio.play().catch(e=>{}); 
        }
    },
    reset: function(){ this.x = canvas.width*0.3; this.y=canvas.height/2; this.velocity=0; this.rotation=0; }
};

const pipes = {
    items:[], w:52, gap:130, dx:3,
    draw:function(){
        for(let p of this.items){
            ctx.fillStyle="#73BF2E"; ctx.fillRect(p.x, 0, this.w, p.top);
            ctx.fillRect(p.x, canvas.height-p.bottom, this.w, p.bottom);
            ctx.strokeStyle="#555"; ctx.strokeRect(p.x, 0, this.w, p.top);
            ctx.strokeRect(p.x, canvas.height-p.bottom, this.w, p.bottom);
        }
    },
    update:function(){
        if(frames%100===0){
            let min=50, max=canvas.height-this.gap-50;
            let topH = Math.random()*(max-min)+min;
            this.items.push({x:canvas.width, top:topH, bottom:canvas.height-this.gap-topH, passed:false});
        }
        for(let i=0; i<this.items.length; i++){
            let p = this.items[i];
            p.x -= this.dx;
            // Collision
            if(bird.x+bird.width/2 > p.x && bird.x-bird.width/2 < p.x+this.w){
                if(bird.y-bird.height/2 < p.top || bird.y+bird.height/2 > canvas.height-p.bottom) gameOver();
            }
            if(p.x + this.w < bird.x && !p.passed) { score++; scoreEl.innerText=score; p.passed=true; }
            if(p.x + this.w < -10) { this.items.shift(); i--; }
        }
    },
    reset:function(){ this.items=[]; }
};

function loop(){
    if(gameState==='PLAYING'){ bird.update(); pipes.update(); frames++; }
    else if(gameState==='START'){ bird.y = canvas.height/2 + Math.sin(Date.now()/300)*5; }
    
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Draw Clouds
    ctx.fillStyle="rgba(255,255,255,0.5)";
    ctx.beginPath(); ctx.arc(100,100,30,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(canvas.width-80,150,40,0,Math.PI*2); ctx.fill();

    pipes.draw(); 
    
    // Ground
    ctx.fillStyle="#ded895"; ctx.fillRect(0,canvas.height-20,canvas.width,20);
    
    bird.draw();
    requestAnimationFrame(loop);
}

function startGame(){ gameState='PLAYING'; menuScreen.style.display='none'; bird.reset(); pipes.reset(); score=0; scoreEl.innerText=0; frames=0; bird.flap(); }
function gameOver(){ 
    gameState='GAMEOVER'; 
    if(score>highScore){ highScore=score; localStorage.setItem('flappyHighScore', highScore); highScoreEl.innerText=`High: ${highScore}`; }
    titleText.innerText="GAME OVER"; infoText.innerText="Tap to Restart"; menuScreen.style.display='flex';
}
function handleInput(e){
    if(e.type!=='keydown') e.preventDefault();
    if(e.type==='keydown' && e.code!=='Space') return;
    if(gameState==='START') startGame();
    else if(gameState==='PLAYING') bird.flap();
    else if(gameState==='GAMEOVER') setTimeout(()=>{ gameState='START'; titleText.innerHTML="FLAPPY<br>GAME"; infoText.innerText="Tap to Start"; bird.reset(); }, 500);
}

window.addEventListener('keydown', handleInput);
const c = document.getElementById('game-container');
c.addEventListener('mousedown', handleInput);
c.addEventListener('touchstart', handleInput, {passive:false});

function resize(){ canvas.width=c.clientWidth; canvas.height=c.clientHeight; }
window.addEventListener('resize', resize);
resize();
bird.reset();
loop();
</script>
</body>
</html>
tboxPadding;
            const birdBottom = bird.y + bird.height/2 - hitboxPadding;

            const pipeLeft = p.x;
            const pipeRight = p.x + this.w;
            const pipeTopY = p.top;
            const pipeBottomY = canvas.height - ground.height - p.bottom;

            // Check Collision X
            if (birdRight > pipeLeft && birdLeft < pipeRight) {
                // Check Collision Y
                if (birdTop < pipeTopY || birdBottom > pipeBottomY) {
                    gameOver();
                }
            }

            // Score update
            if (p.x + this.w < bird.x && !p.passed) {
                score++;
                scoreEl.innerText = score;
                p.passed = true;
            }

            // Remove off-screen pipes
            if (p.x + this.w < -10) {
                this.items.shift();
                i--;
            }
        }
    },

    reset: function() {
        this.items = [];
    }
};

const ground = {
    height: 100, // Taller ground to fit UI better on mobile
    x: 0,
    update: function() {
        this.x -= gameSpeed;
        if (this.x <= -20) this.x = 0;
    },
    draw: function() {
        ctx.fillStyle = "#ded895";
        ctx.fillRect(0, canvas.height - this.height, canvas.width, this.height);
        
        // Grass top
        ctx.fillStyle = "#73bf2e";
        ctx.fillRect(0, canvas.height - this.height, canvas.width, 12);
        ctx.beginPath();
        ctx.moveTo(0, canvas.height - this.height + 12);
        ctx.lineTo(canvas.width, canvas.height - this.height + 12);
        ctx.strokeStyle = "#558c22";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
};

/**
 * GAME ENGINE
 */

function init() {
    resizeCanvas();
    bird.reset();
    loop();
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw Background Items
    drawClouds();

    if (gameState === 'PLAYING') {
        bird.update();
        pipes.update();
        ground.update();
        frames++;
    } else if (gameState === 'START') {
        // Idle animation
        bird.y = (canvas.height / 2) + Math.sin(Date.now() / 300) * 10;
        ground.update();
    }

    pipes.draw();
    ground.draw();
    bird.draw();

    requestAnimationFrame(loop);
}

function drawClouds() {
    // Simple procedural clouds
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
    const t = Date.now() / 10000;
    for(let i=0; i<3; i++) {
        let x = ((i * 150) + (t * 50)) % (canvas.width + 100) - 50;
        let y = 50 + i * 40;
        ctx.beginPath();
        ctx.arc(x, y, 30, 0, Math.PI * 2);
        ctx.arc(x + 25, y - 10, 40, 0, Math.PI * 2);
        ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
        ctx.fill();
    }
}

function startGame() {
    gameState = 'PLAYING';
    menuScreen.style.display = 'none';
    bird.reset();
    pipes.reset();
    score = 0;
    scoreEl.innerText = score;
    frames = 0;
    bird.flap();
}

function gameOver() {
    if (gameState === 'GAMEOVER') return; // Prevent double trigger
    
    gameState = 'GAMEOVER';
    
    // Flash effect
    flashDiv.style.opacity = '0.6';
    setTimeout(() => flashDiv.style.opacity = '0', 100);

    // Update High Score
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('flappyHighScore', highScore);
        highScoreEl.innerText = `High: ${highScore}`;
    }

    titleText.innerHTML = "GAME<br>OVER";
    infoText.innerText = "TAP TO RESTART";
    menuScreen.style.display = 'flex';

    // Prevent immediate restart click
    menuScreen.style.pointerEvents = 'none';
    setTimeout(() => {
        menuScreen.style.pointerEvents = 'auto';
    }, 500);
}

/**
 * INPUT HANDLING
 */
function handleInput(e) {
    if (e.type === 'keydown' && e.code !== 'Space') return;
    if (e.type !== 'keydown') e.preventDefault(); // Stop mouse/touch defaults

    switch (gameState) {
        case 'START':
            startGame();
            break;
        case 'PLAYING':
            bird.flap();
            break;
        case 'GAMEOVER':
            // Reset to START state
            gameState = 'START';
            titleText.innerHTML = "FLAPPY<br>BIRD";
            infoText.innerText = "TAP TO START";
            bird.reset();
            pipes.reset();
            break;
    }
}

// Event Listeners
window.addEventListener('keydown', handleInput);
const container = document.getElementById('game-container');
container.addEventListener('mousedown', handleInput);
container.addEventListener('touchstart', handleInput, { passive: false });

function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);

// Start
init();
</script>
</body>
</html>
score % 10 === 0) this.dx += 0.5; 
                    }

                    // Remove off-screen pipes
                    if (p.x + this.w < 0) {
                        this.items.shift();
                        i--;
                    }
                }
            },

            reset: function() {
                this.items = [];
            }
        };

        // Moving Background/Ground (Visual flair)
        const ground = {
            height: 20,
            x: 0,
            update: function() {
                // Move left to create parallax/speed effect
                this.x -= gameSpeed;
                if (this.x <= -20) this.x = 0;
            },
            draw: function() {
                ctx.fillStyle = "#ded895";
                ctx.fillRect(0, canvas.height - this.height, canvas.width, this.height);
                
                // Moving pattern on ground
                ctx.fillStyle = "#d1ad6b";
                for(let i = this.x; i < canvas.width; i+=20) {
                    ctx.fillRect(i, canvas.height - this.height, 10, this.height);
                }
                
                // Border top
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - this.height);
                ctx.lineTo(canvas.width, canvas.height - this.height);
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        };

        /* =========================================
           3. GAME LOOP & LOGIC
           ========================================= */

        function init() {
            resizeCanvas();
            bird.reset();
            loop();
        }

        function loop() {
            // Update
            if (gameState === 'PLAYING') {
                bird.update();
                pipes.update();
                ground.update();
                frames++;
            } else if (gameState === 'START') {
                // Bobbing animation for bird at start
                bird.y = (canvas.height / 2) + Math.sin(Date.now() / 300) * 5;
                ground.update(); // Keep ground moving for life
            }

            // Draw
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Background clouds (simple procedural)
            drawClouds();

            pipes.draw();
            ground.draw();
            bird.draw();

            requestAnimationFrame(loop);
        }

        function drawClouds() {
            // Simple static background decoration
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
            ctx.beginPath();
            ctx.arc(100, 100, 30, 0, Math.PI * 2);
            ctx.arc(130, 110, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(canvas.width - 80, 200, 40, 0, Math.PI * 2);
            ctx.arc(canvas.width - 120, 210, 30, 0, Math.PI * 2);
            ctx.fill();
        }

        /* =========================================
           4. CONTROLS & STATE MANAGEMENT
           ========================================= */

        function startGame() {
            gameState = 'PLAYING';
            menuScreen.style.display = 'none';
            bird.reset();
            pipes.reset();
            score = 0;
            scoreEl.innerText = score;
            frames = 0;
            bird.flap(); // Initial jump
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            
            // Check High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyHighScore', highScore);
                highScoreEl.innerText = `High Score: ${highScore}`;
            }

            // Show UI
            titleText.innerText = "GAME OVER";
            infoText.innerText = "Tap to Restart";
            menuScreen.style.display = 'flex';
        }

        function handleInput(e) {
            // Prevent default behavior for touch/click to avoid double firing or scrolling
            if(e.type === 'touchstart') e.preventDefault(); 
            if(e.type === 'keydown' && e.code !== 'Space') return; // Only spacebar

            switch (gameState) {
                case 'START':
                    startGame();
                    break;
                case 'PLAYING':
                    bird.flap();
                    break;
                case 'GAMEOVER':
                    // Short delay to prevent accidental restart immediately after dying
                    setTimeout(() => {
                        gameState = 'START';
                        titleText.innerHTML = "FLAPPY<br>GAME";
                        infoText.innerText = "Tap to Start";
                        bird.reset(); // Reset position for the menu bobbing
                    }, 200);
                    break;
            }
        }

        // Event Listeners
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput(e);
        });
        
        // Mouse and Touch
        // We bind to the game container to ensure coordinates are relative if needed, 
        // though here we just need the trigger.
        const container = document.getElementById('game-container');
        container.addEventListener('mousedown', handleInput);
        container.addEventListener('touchstart', handleInput, {passive: false});

        /* =========================================
           5. RESPONSIVENESS
           ========================================= */
        function resizeCanvas() {
            // Get container dimensions
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Adjust pipe gap based on height for playability
            pipes.gap = canvas.height * 0.22; // ~22% of screen height
            if(pipes.gap < 100) pipes.gap = 100; // Minimum gap
        }

        window.addEventListener('resize', resizeCanvas);

        // Start
        init();

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Flappy Custom Game</title>
<style>
    body {
        margin: 0;
        padding: 0;
        background-color: #333;
        font-family: 'Arial', sans-serif;
        overflow: hidden;
        touch-action: none;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
    }

    #game-container {
        position: relative;
        width: 100%;
        height: 100%;
        max-width: 480px;
        max-height: 800px;
        background-color: #70c5ce;
        overflow: hidden;
    }

    canvas {
        display: block;
        width: 100%;
        height: 100%;
    }

    .ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    .score-board {
        padding: 20px;
        text-align: center;
        color: white;
        text-shadow: 2px 2px 0 #000;
        z-index: 10;
    }

    #current-score { font-size: 3rem; font-weight: bold; display: block; }
    #high-score-display { font-size: 1.2rem; margin-top: 5px; display: block; }

    #menu-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 20;
        pointer-events: auto;
        cursor: pointer;
    }

    #menu-screen h1 { color: white; font-size: 3rem; margin: 0 0 10px 0; text-shadow: 3px 3px 0 #000; text-align: center; }
    #menu-screen p { color: #fff; font-size: 1.5rem; text-align: center; animation: blink 1.5s infinite; }

    @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    #assets { display: none; }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <div class="score-board">
            <span id="current-score">0</span>
            <span id="high-score-display">High Score: 0</span>
        </div>
    </div>

    <div id="menu-screen">
        <h1 id="title-text">FLAPPY<br>GAME</h1>
        <p id="info-text">Tap or Click to Start</p>
    </div>
</div>

<div id="assets">
    <img id="playerImg" src="player.png" alt="Player">
    <audio id="jumpSound" src="jump.mp3" preload="auto"></audio>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreEl = document.getElementById('current-score');
const highScoreEl = document.getElementById('high-score-display');
const menuScreen = document.getElementById('menu-screen');
const titleText = document.getElementById('title-text');
const infoText = document.getElementById('info-text');

const birdImg = document.getElementById('playerImg');
const jumpAudio = document.getElementById('jumpSound');

let frames = 0;
let score = 0;
let highScore = localStorage.getItem('flappyHighScore') || 0;
let gameState = 'START';
let gameSpeed = 3;

highScoreEl.innerText = `High Score: ${highScore}`;

const bird = {
    x: 50,
    y: 150,
    width: 60,
    height: 60,
    velocity: 0,
    gravity: 0.25,
    jumpStrength: 4.6,
    rotation: 0,
    
    draw: function() {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (gameState === 'PLAYING' || gameState === 'GAMEOVER') {
            if (this.velocity < 0) this.rotation = -25 * Math.PI / 180;
            else {
                this.rotation += 0.1;
                if(this.rotation > 90 * Math.PI / 180) this.rotation = 90 * Math.PI / 180;
            }
        } else { this.rotation = 0; }
        ctx.rotate(this.rotation);

        // âœ… Draw as circle
        ctx.beginPath();
        ctx.arc(0, 0, this.width/2, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();

        if (birdImg.complete && birdImg.naturalHeight !== 0) {
            ctx.drawImage(birdImg, -this.width/2, -this.height/2, this.width, this.height);
        } else {
            ctx.fillStyle = "yellow";
            ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        }

        ctx.restore();
    },

    update: function() {
        this.velocity += this.gravity;
        this.y += this.velocity;

        if (this.y + this.height/2 >= canvas.height - 20) {
            this.y = canvas.height - 20 - this.height/2;
            gameOver();
        }

        if (this.y - this.height/2 <= 0) {
            this.y = this.height/2;
            this.velocity = 0;
        }
    },

    flap: function() {
        this.velocity = -this.jumpStrength;
        this.rotation = -25 * Math.PI / 180;

        if (jumpAudio) {
            const soundClone = jumpAudio.cloneNode();
            soundClone.volume = 0.5;
            soundClone.play().catch(e => console.log("Audio play failed: ", e));
        }
    },

    reset: function() {
        this.x = canvas.width * 0.3;
        this.y = canvas.height / 2;
        this.velocity = 0;
        this.rotation = 0;
    }
};

const pipes = {
    items: [],
    w: 52,
    gap: 120,
    dx: 3,
    
    draw: function() {
        for (let p of this.items) {
            ctx.fillStyle = "#73BF2E";
            ctx.strokeStyle = "#558c22";
            ctx.lineWidth = 2;
            ctx.fillRect(p.x, 0, this.w, p.top);
            ctx.strokeRect(p.x, 0, this.w, p.top);
            ctx.fillRect(p.x, canvas.height - p.bottom, this.w, p.bottom);
            ctx.strokeRect(p.x, canvas.height - p.bottom, this.w, p.bottom);
        }
    },

    update: function() {
        const spawnRate = Math.floor(canvas.width / 2.5);
        if (frames % (spawnRate > 60 ? spawnRate : 100) === 0) {
            const minHeight = canvas.height * 0.1;
            const maxTop = canvas.height - this.gap - minHeight;
            const topHeight = Math.random() * (maxTop - minHeight) + minHeight;
            const bottomHeight = canvas.height - this.gap - topHeight;
            this.items.push({ x: canvas.width, top: topHeight, bottom: bottomHeight, passed: false });
        }

        for (let i = 0; i < this.items.length; i++) {
            let p = this.items[i];
            p.x -= this.dx;

            if (bird.x + bird.width/2 > p.x && bird.x - bird.width/2 < p.x + this.w) {
                if (bird.y - bird.height/2 < p.top || bird.y + bird.height/2 > canvas.height - p.bottom) gameOver();
            }

            if (p.x + this.w < bird.x && !p.passed) {
                score++;
                scoreEl.innerText = score;
                p.passed = true;
            }

            if (p.x + this.w < 0) { this.items.shift(); i--; }
        }
    },

    reset: function() { this.items = []; }
};

const ground = {
    height: 20,
    x: 0,
    update: function() { this.x -= gameSpeed; if (this.x <= -20) this.x = 0; },
    draw: function() {
        ctx.fillStyle = "#ded895";
        ctx.fillRect(0, canvas.height - this.height, canvas.width, this.height);
        ctx.fillStyle = "#d1ad6b";
        for(let i = this.x; i < canvas.width; i+=20) ctx.fillRect(i, canvas.height - this.height, 10, this.height);
        ctx.beginPath(); ctx.moveTo(0, canvas.height - this.height); ctx.lineTo(canvas.width, canvas.height - this.height);
        ctx.strokeStyle = "#555"; ctx.lineWidth = 2; ctx.stroke();
    }
};

function init() { resizeCanvas(); bird.reset(); loop(); }

function loop() {
    if (gameState === 'PLAYING') { bird.update(); pipes.update(); ground.update(); frames++; }
    else if (gameState === 'START') { bird.y = (canvas.height/2)+Math.sin(Date.now()/300)*5; ground.update(); }

    ctx.clearRect(0,0,canvas.width,canvas.height);
    pipes.draw(); ground.draw(); bird.draw();
    requestAnimationFrame(loop);
}

function startGame() {
    gameState='PLAYING'; menuScreen.style.display='none'; bird.reset(); pipes.reset(); score=0; scoreEl.innerText=score; frames=0; bird.flap();
}

function gameOver() {
    gameState='GAMEOVER';
    if(score>highScore){ highScore=score; localStorage.setItem('flappyHighScore', highScore); highScoreEl.innerText=`High Score: ${highScore}`; }
    titleText.innerText="GAME OVER"; infoText.innerText="Tap to Restart"; menuScreen.style.display='flex';
}

function handleInput(e) {
    if(e.type==='touchstart') e.preventDefault();
    if(e.type==='keydown' && e.code!=='Space') return;

    switch(gameState){
        case 'START': startGame(); break;
        case 'PLAYING': bird.flap(); break;
        case 'GAMEOVER':
            setTimeout(()=>{ gameState='START'; titleText.innerHTML="FLAPPY<br>GAME"; infoText.innerText="Tap to Start"; bird.reset(); },200);
            break;
    }
}

window.addEventListener('keydown',(e)=>{if(e.code==='Space') handleInput(e);});
const container=document.getElementById('game-container');
container.addEventListener('mousedown',handleInput);
container.addEventListener('touchstart',handleInput,{passive:false});

function resizeCanvas() {
    const container = document.getElementById('game-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    pipes.gap = canvas.height * 0.22;
    if(pipes.gap<100) pipes.gap=100;
}

window.addEventListener('resize', resizeCanvas);
init();
</script>

</body>
</html>

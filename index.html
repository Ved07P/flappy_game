<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy HTML5</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        canvas {
            background-color: #70c5ce;
            display: block;
            width: 100%;
            height: auto;
            max-width: 480px;
            aspect-ratio: 320/480;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="320" height="480"></canvas>

<script>
    const cvs = document.getElementById("gameCanvas");
    const ctx = cvs.getContext("2d");

    const DEGREE = Math.PI / 180;
    const FRAMES_PER_PIPE = 100;
    
    const birdImg = new Image();
    birdImg.src = "player.png";

    const jumpAudio = new Audio();
    jumpAudio.src = "jump.mp3";

    let frames = 0;
    
    const state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    function userAction(e) {
        if(e.type === 'touchstart') e.preventDefault(); 

        switch (state.current) {
            case state.getReady:
                state.current = state.game;
                jumpAudio.play().catch(e => console.log("Interaction needed for audio"));
                bird.flap();
                break;
            case state.game:
                bird.flap();
                break;
            case state.over:
                resetGame();
                break;
        }
    }

    window.addEventListener("keydown", (e) => {
        if (e.code === "Space") userAction(e);
    });
    cvs.addEventListener("mousedown", userAction);
    cvs.addEventListener("touchstart", userAction, {passive: false});

    const bg = {
        draw: function() {
            ctx.fillStyle = "#70c5ce";
            ctx.fillRect(0, 0, cvs.width, cvs.height);
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.beginPath();
            ctx.arc(100, 350, 40, 0, Math.PI * 2);
            ctx.arc(160, 360, 50, 0, Math.PI * 2);
            ctx.arc(200, 340, 30, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(280, 100, 40, 0, Math.PI * 2);
            ctx.arc(330, 120, 30, 0, Math.PI * 2);
            ctx.fill();
        }
    };

    const fg = {
        h: 112,
        x: 0,
        dx: 2,
        draw: function() {
            ctx.fillStyle = "#ded895";
            ctx.fillRect(0, cvs.height - this.h, cvs.width, this.h);
            ctx.fillStyle = "#73bf2e";
            ctx.fillRect(0, cvs.height - this.h, cvs.width, 15);
            ctx.strokeStyle = "#558c22";
            ctx.beginPath();
            ctx.moveTo(0, cvs.height - this.h + 15);
            ctx.lineTo(cvs.width, cvs.height - this.h + 15);
            ctx.stroke();
        },
        update: function() {
            if (state.current === state.game) {
                this.x = (this.x - this.dx) % (cvs.width / 2);
            }
        }
    };

    const bird = {
        x: 50,
        y: 150,
        w: 34,
        h: 34,
        radius: 17,
        speed: 0,
        gravity: 0.25,
        jump: 4.6,
        rotation: 0,
        
        draw: function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            let rot = this.speed * 0.1;
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, rot));
            ctx.rotate(this.rotation);
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(birdImg, -this.radius, -this.radius, this.w, this.h);
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#fff";
            ctx.stroke();
            ctx.restore();
        },
        
        flap: function() {
            this.speed = -this.jump;
            jumpAudio.pause();
            jumpAudio.currentTime = 0;
            jumpAudio.play();
        },
        
        update: function() {
            if (state.current === state.getReady) {
                this.y = 150 - 5 * Math.cos(frames * DEGREE * 5);
                this.rotation = 0;
            } else {
                this.speed += this.gravity;
                this.y += this.speed;
                if (this.y + this.radius >= cvs.height - fg.h) {
                    this.y = cvs.height - fg.h - this.radius;
                    if (state.current === state.game) {
                        state.current = state.over;
                    }
                }
            }
        },
        reset: function() {
            this.speed = 0;
            this.y = 150;
            this.rotation = 0;
        }
    };

    const pipes = {
        items: [],
        w: 52,
        h: 400,
        dx: 2,
        gap: 100,
        
        draw: function() {
            for (let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                let topY = p.y;
                let bottomY = p.y + this.h + this.gap;
                ctx.fillStyle = "#73bf2e";
                ctx.strokeStyle = "#558c22";
                ctx.lineWidth = 2;
                ctx.fillRect(p.x, topY, this.w, this.h);
                ctx.strokeRect(p.x, topY, this.w, this.h);
                ctx.fillRect(p.x, bottomY, this.w, this.h);
                ctx.strokeRect(p.x, bottomY, this.w, this.h);
            }
        },
        
        update: function() {
            if (state.current !== state.game) return;
            if (frames % FRAMES_PER_PIPE === 0) {
                this.items.push({
                    x: cvs.width,
                    y: -150 * (Math.random() + 1)
                });
            }
            for (let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                p.x -= this.dx;
                let birdRight = bird.x + bird.radius - 2;
                let birdLeft = bird.x - bird.radius + 2;
                let birdTop = bird.y - bird.radius + 2;
                let birdBottom = bird.y + bird.radius - 2;
                let pipeLeft = p.x;
                let pipeRight = p.x + this.w;
                let topPipeBottom = p.y + this.h;
                let bottomPipeTop = p.y + this.h + this.gap;
                if (birdRight > pipeLeft && birdLeft < pipeRight) {
                    if (birdTop < topPipeBottom || birdBottom > bottomPipeTop) {
                        state.current = state.over;
                    }
                }
                if (p.x + this.w <= 0) {
                    this.items.shift();
                    score.value += 1;
                    score.best = Math.max(score.value, score.best);
                    localStorage.setItem("flappy_highscore", score.best);
                }
            }
        },
        reset: function() {
            this.items = [];
        }
    };

    const score = {
        best: localStorage.getItem("flappy_highscore") || 0,
        value: 0,
        draw: function() {
            ctx.fillStyle = "#FFF";
            ctx.strokeStyle = "#000";
            if (state.current === state.game) {
                ctx.lineWidth = 2;
                ctx.font = "35px Impact";
                ctx.fillText(this.value, cvs.width / 2, 50);
                ctx.strokeText(this.value, cvs.width / 2, 50);
            } else if (state.current === state.over) {
                ctx.font = "25px Impact";
                ctx.fillText("Score: " + this.value, 110, 180);
                ctx.strokeText("Score: " + this.value, 110, 180);
                ctx.fillText("Best: " + this.best, 115, 220);
                ctx.strokeText("Best: " + this.best, 115, 220);
            }
        },
        reset: function() {
            this.value = 0;
        }
    };

    function draw() {
        bg.draw();
        pipes.draw();
        fg.draw();
        bird.draw();
        score.draw();
        ctx.fillStyle = "#FFF";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.textAlign = "center";
        if (state.current === state.getReady) {
            ctx.font = "40px Impact";
            ctx.fillText("Get Ready", cvs.width/2, 200);
            ctx.strokeText("Get Ready", cvs.width/2, 200);
            ctx.font = "20px Arial";
            ctx.fillText("Tap to Fly", cvs.width/2, 240);
        } else if (state.current === state.over) {
            ctx.font = "40px Impact";
            ctx.fillText("Game Over", cvs.width/2, 130);
            ctx.strokeText("Game Over", cvs.width/2, 130);
            ctx.fillStyle = "#f88";
            ctx.fillRect(100, 260, 120, 40);
            ctx.fillStyle = "#FFF";
            ctx.font = "20px Arial";
            ctx.fillText("Play Again", 160, 287);
        }
    }

    function update() {
        bird.update();
        fg.update();
        pipes.update();
    }

    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    function resetGame() {
        bird.reset();
        pipes.reset();
        score.reset();
        frames = 0;
        state.current = state.getReady;
    }

    loop();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* Prevent scrolling on mobile */
            touch-action: none; /* Disable default touch actions */
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            background-color: #70c5ce; /* Sky blue */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* Maintain Aspect Ratio Logic */
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 320/480; 
        }
    </style>
</head>
<body>

<canvas id="birdCanvas" width="320" height="480"></canvas>

<script>
    // --- CONFIGURATION & ASSETS ---
    const cvs = document.getElementById("birdCanvas");
    const ctx = cvs.getContext("2d");

    // Game Variables
    let frames = 0;
    const DEGREE = Math.PI / 180;
    
    // Load Images and Sounds
    const playerSprite = new Image();
    playerSprite.src = "player.png";

    const jumpSound = new Audio();
    jumpSound.src = "jump.mp3";

    // Game State Management
    const state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    // Control Handling
    const startAction = () => {
        switch (state.current) {
            case state.getReady:
                state.current = state.game;
                break;
            case state.game:
                bird.flap();
                break;
            case state.over:
                resetGame();
                break;
        }
    };

    // Event Listeners (Mouse, Touch, Keyboard)
    cvs.addEventListener("click", startAction);
    window.addEventListener("keydown", (e) => {
        if (e.code === "Space") startAction();
    });

    // --- GAME OBJECTS ---

    // 1. The Background (Clouds)
    const bg = {
        draw: function() {
            ctx.fillStyle = "#70c5ce";
            ctx.fillRect(0, 0, cvs.width, cvs.height);
            
            // Draw simple procedural clouds
            ctx.fillStyle = "#FFF";
            // Cloud 1
            ctx.beginPath();
            ctx.arc(100, 350, 30, 0, Math.PI * 2);
            ctx.arc(140, 350, 40, 0, Math.PI * 2);
            ctx.arc(180, 350, 30, 0, Math.PI * 2);
            ctx.fill();
            // Cloud 2
            ctx.beginPath();
            ctx.arc(280, 100, 30, 0, Math.PI * 2);
            ctx.arc(320, 100, 40, 0, Math.PI * 2);
            ctx.fill();
        }
    };

    // 2. The Ground
    const fg = {
        h: 112,
        x: 0,
        dx: 2,
        draw: function() {
            ctx.fillStyle = "#ded895";
            ctx.fillRect(0, cvs.height - this.h, cvs.width, this.h);
            // Grass top
            ctx.fillStyle = "#73bf2e";
            ctx.fillRect(0, cvs.height - this.h, cvs.width, 20);
            // Moving effect border
            ctx.strokeStyle = "#558c22";
            ctx.beginPath();
            ctx.moveTo(this.x, cvs.height - this.h);
            ctx.lineTo(this.x, cvs.height);
            ctx.stroke();
        },
        update: function() {
            if (state.current == state.game) {
                this.x = (this.x - this.dx) % (cvs.width / 2);
            }
        }
    };

    // 3. The Bird
    const bird = {
        animation: [0, 1, 2, 1],
        x: 50,
        y: 150,
        speed: 0,
        gravity: 0.25,
        jumpStrength: 4.6,
        radius: 12, // Hitbox radius
        rotation: 0,
        
        draw: function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Rotation based on speed
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.speed * 0.1))); // Clamp rotation
            ctx.rotate(this.rotation);

            // Draw Circle Mask
            ctx.beginPath();
            ctx.arc(0, 0, this.radius + 2, 0, Math.PI*2); // +2 for border
            ctx.fillStyle = "white";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#333";
            ctx.stroke();
            ctx.closePath();

            // Clip image inside circle
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI*2);
            ctx.clip();
            
            // Draw Player Image
            // We assume image is square; if not, adjust width/height
            if(playerSprite.complete) {
                ctx.drawImage(playerSprite, -this.radius, -this.radius, this.radius*2, this.radius*2);
            } else {
                // Fallback if image not loaded
                ctx.fillStyle = "orange";
                ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
            }

            ctx.restore();
        },
        
        flap: function() {
            this.speed = -this.jumpStrength;
            
            // Audio Logic: Restart sound if already playing
            jumpSound.currentTime = 0;
            jumpSound.play().catch(e => console.log("Audio interaction needed first"));
        },
        
        update: function() {
            // Period (floating) in Get Ready state
            if (state.current == state.getReady) {
                this.y = 150 - 5 * Math.cos(frames * DEGREE * 5); // Hover effect
            } else {
                this.speed += this.gravity;
                this.y += this.speed;

                // Collision with floor
                if (this.y + this.radius >= cvs.height - fg.h) {
                    this.y = cvs.height - fg.h - this.radius;
                    if (state.current == state.game) {
                        state.current = state.over;
                    }
                }
            }
        },
        
        reset: function() {
            this.speed = 0;
            this.rotation = 0;
            this.y = 150;
        }
    };

    // 4. The Pipes
    const pipes = {
        position: [],
        w: 53,
        h: 400,
        gap: 100, // Space between top and bottom pipe
        dx: 2,
        
        draw: function() {
            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.h + this.gap;

                ctx.fillStyle = "#73bf2e";
                ctx.strokeStyle = "#558c22";
                ctx.lineWidth = 2;

                // Top Pipe
                ctx.fillRect(p.x, topY, this.w, this.h);
                ctx.strokeRect(p.x, topY, this.w, this.h);
                
                // Bottom Pipe
                ctx.fillRect(p.x, bottomY, this.w, this.h);
                ctx.strokeRect(p.x, bottomY, this.w, this.h);
            }
        },
        
        update: function() {
            if (state.current !== state.game) return;

            // Add new pipe every 100 frames
            if (frames % 120 == 0) {
                this.position.push({
                    x: cvs.width,
                    y: -150 * (Math.random() + 1)
                });
            }

            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx;

                // Collision Detection (Circle vs Rectangle)
                // 1. Top Pipe
                let bottomPipeY = p.y + this.h + this.gap;
                
                // Helper for AABB collision
                if (
                    bird.x + bird.radius > p.x && 
                    bird.x - bird.radius < p.x + this.w && 
                    bird.y + bird.radius > p.y && 
                    bird.y - bird.radius < p.y + this.h
                ) {
                    state.current = state.over;
                }
                // 2. Bottom Pipe
                if (
                    bird.x + bird.radius > p.x && 
                    bird.x - bird.radius < p.x + this.w && 
                    bird.y + bird.radius > bottomPipeY && 
                    bird.y - bird.radius < bottomPipeY + this.h
                ) {
                    state.current = state.over;
                }

                // Remove pipes that go off screen
                if (p.x + this.w <= 0) {
                    this.position.shift();
                    score.value += 1;
                    score.best = Math.max(score.value, score.best);
                    localStorage.setItem("flappyHighScore", score.best);
                }
            }
        },
        
        reset: function() {
            this.position = [];
        }
    };

    // 5. UI (Score, Start Screen, Game Over)
    const score = {
        best: localStorage.getItem("flappyHighScore") || 0,
        value: 0,
        
        draw: function() {
            ctx.fillStyle = "#FFF";
            ctx.strokeStyle = "#000";
            
            if (state.current == state.game) {
                ctx.lineWidth = 2;
                ctx.font = "35px Impact";
                ctx.fillText(this.value, cvs.width / 2 - 10, 50);
                ctx.strokeText(this.value, cvs.width / 2 - 10, 50);
            } else if (state.current == state.over) {
                // Game Over Score Card
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fillRect(60, 150, 200, 160);
                ctx.strokeRect(60, 150, 200, 160);

                ctx.fillStyle = "#333";
                ctx.font = "25px Impact";
                ctx.fillText("Score: " + this.value, 80, 200);
                ctx.fillText("Best: " + this.best, 80, 240);

                ctx.font = "20px Arial";
                ctx.fillStyle = "#555";
                ctx.fillText("Tap to Restart", 95, 280);
            } else if (state.current == state.getReady) {
                ctx.fillStyle = "#FFF";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.font = "40px Impact";
                ctx.fillText("Get Ready", 80, 200);
                ctx.strokeText("Get Ready", 80, 200);
                
                ctx.font = "20px Arial";
                ctx.fillText("Tap or Space to Jump", 65, 240);
            }
        },
        
        reset: function() {
            this.value = 0;
        }
    };

    // --- GAME LOOP & UTILS ---

    function resetGame() {
        bird.reset();
        pipes.reset();
        score.reset();
        frames = 0;
        state.current = state.getReady;
    }

    function draw() {
        bg.draw();
        pipes.draw();
        fg.draw();
        bird.draw();
        score.draw();
    }

    function update() {
        bird.update();
        fg.update();
        pipes.update();
    }

    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    // Start
    loop();

</script>
</body>
</html>
